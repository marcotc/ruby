prelude: |
  def full_backtrace(ex)
    backtrace = String.new
    backtrace_for(ex, backtrace)

    # Avoid circular causes
    causes = {}
    causes[ex] = true

    while (cause = ex.cause) && !causes.key?(cause)
      backtrace_for(cause, backtrace)
      causes[cause] = true
    end

    backtrace
  end

  def backtrace_for(ex, backtrace)
    trace = ex.backtrace
    return unless trace

    if trace[0]
      backtrace << trace[0]
      backtrace << ': '
      backtrace << ex.message
      backtrace << ' ('
      backtrace << ex.class.to_s
      backtrace << ')'
    end

    if trace[1]
      trace[1..-1].each do |line|
        backtrace << "\n\tfrom "
        backtrace << line
      end
    end

    backtrace << "\n"
  end

  class Test
    def root
      raise 'root cause'
    end

    def wrapper
      root
    rescue
      raise 'wrapper layer'
    end

    def call
      wrapper
    rescue => e
      e
    end
  end

  ex = Test.new.call
benchmark:
  full_message: ex.full_message
  full_message_no_highlight: 'ex.full_message(highlight: false)'
  full_message_top: 'ex.full_message(order: :top)'
  full_message_bottom: 'ex.full_message(order: :bottom)' # fastest C
  full_message_no_highlight_order: 'ex.full_message(highlight: false, order: :top)' # fastest overall
  ruby_impl: full_backtrace(ex)
loop_count: 1000000
